\documentclass[sts]{imsart}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{url}
\usepackage{media9}
\usepackage[authoryear]{natbib}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true]
 {hyperref}
\hypersetup{
 citecolor=blue,urlcolor=blue}

\newcommand{\hh}[1]{{\color{magenta} #1}}

\begin{document}

<<setup, include=FALSE>>=
options(replace.assign=TRUE, reindent.spaces=2, width=70)
knit_hooks$set(document=hook_movecode, par = function(before, options, envir) {
  if (before && options$fig.show != "none") {
    par(mar = c(4, 4, 0.1, 0.1), cex.lab = 0.95, cex.axis = 0.9,
        mgp = c(2, 0.7, 0), tcl = -0.3, las = 1)
    if (is.list(options$par)) do.call(par, options$par)
  }
})
set.seed(123)
@

\begin{frontmatter}


\title{Reactive Programming for Interactive Graphics}

\maketitle
\runtitle{Reactive Programming for Interactive Graphics}

\begin{aug}
\author{Yihui Xie\ead[label=e1]{xie@iastate.edu}\ead[label=u1,url]{http://yihui.name}}
\and
\author{Heike Hofmann \ead[label=e2]{hofmann@iastate.edu}\ead[label=u2,url]{http://hofmann.public.iastate.edu}}
\affiliation{Department of Statistics, Iowa State University}
\address{Yihui Xie is Graduate Student, Department of Statistics, Iowa State University, 2215 Snedecor Hall, Ames 50011, IA, USA \printead{e1,u1}}
\address{Heike Hofmann is Associate Professor, Department of Statistics, Iowa State University, 2413 Snedecor Hall, Ames 50011, IA, USA \printead{e2,u2}}
\runauthor{Xie and Hofmann}
\end{aug}
\begin{abstract}
One of the big challenges of developing interactive statistical applications is the management of the data pipeline, which typically consists of many modules. The user's interactions needs to be propagated through these modules and finally be reflected in the output representation. Each individual module may be easy to develop and manage, but the dependency structure can be quite challenging. The MVC (Model/View/Controller) pattern is an attempt to solve the problem by separating the user's interaction from the representation of the data. In this paper we discuss the paradigm of {\it reactive programming} in the framework of the MVC architecture and show its applicability to interactive graphics. Under this paradigm, developers  benefit from the separation of user interaction from the graphical representation, which makes it easier for users and developers to extend interactive applications. The implementation is done in the R package \textbf{cranvas}, which is freely available on Github.
\end{abstract}

\begin{keyword}
\kwd{Reactive programming}
\kwd{Interactive graphics}
\kwd{R language}
\end{keyword}
\end{frontmatter}


\section{Introduction}

%\hh{This needs a gentler introduction -- }
%\hh{
%Start with a discussion of interactive graphics -- where does it come from, }

% ---
% I was assuming the audience should be very familiar with this (Yihui)
% ---

Interactive graphics progresses us beyond the limitations of static
statistical displays, in particular, for exploring high-dimensional data.
With a static image, we can only see one aspect of the data at one time.
Interactive graphics allows us to inspect data dynamically from multiple angles.
For example, we may examine the distribution of a variable from a histogram, and
change its binwidth on the fly without having to manually redraw the plot again and again
according to different values of the binwidth.


The main tasks that an interactive graphics system is supposed to allow are:

\begin{enumerate}
\item Single display interactions, such as modifying the plot attributes (brushing, zooming, panning, deletion) and obtaining additional information (querying graphical elements)
\item Linking between different displays of the same dataset or connected datasets
\end{enumerate}

The first set of tasks is easier to solve -- there are a lot of web applications
that allow various single display interactions based on, for instance,
Gapminder \citep{RJ2009}, ManyEyes \citep{viegas2007}, and D3 \citep{bostock2011d3}.
That is what people usually associate with interactive graphics.

Linked graphics is more tricky - it allows changes across different displays as well as across different aggregation levels of the data. For example, suppose we have a scatterplot of the variable
\texttt{Y} versus \texttt{X}, and a histogram of \texttt{Z} (all three variables
are from the same dataset); when we highlight a subset of points in the scatterplot,
and we need to show the distribution of the subset of \texttt{Z} in the histogram as well.
The key question is how to let the plots be aware of each other's changes, and respond
both automatically and immediately.

A number of standalone systems for interactive statistical graphics exist.
Early systems include PRIM-9, an interactive computer graphics system to picture, rotate, isolate and mask data in up to 9 dimensions \citep{prim9}. More recent packages include
XGobi and GGobi \citep{swayne2003,cook07}, MANET \citep{unwin96}
and Mondrian \citep{theus02}, which support interactive displays
of multivariate data, but they lack the extensibility, and tight integration
with modeling that R furnishes.

One of the big challenges in the development of interactive statistical applications is to resolve a user's action on the data level. This is sometimes referred to as the `plumbing' of interactice graphics
\citep{buja1988,wickham2009plumbing}. In following sections, we start with the
discussion of the classical MVC design, and show the role of reactive programming
in designing an interactive graphics system.

\section{The MVC Architecture}

The Model/View/Controller (MVC) triple is a software architecture pattern
first described by \citet{Krasner1988}. It is widely used in GUI
(Graphical User Interface) applications, including web applications
\citep{leff2001web}. The main reason for its popularity is because
it minimizes the dependencies between  different components of an application.

For example, let us assume that the model component consists of a data transformation, such as a square-root or log transformation. The model does not depend on the view, but the view depends on the model in the sense, that if the data is changed or a different data transformation is chosen, the view has to be updated to reflect this change.
%For example, the model component can be data transformation, and it
%does not need to depend on the view -- the view depends on the model
%in the sense that when the data is changed (e.g. from square-root
%transformation to log transformation), the view will reflect the change.
The model developer therefore never needs to deal with the representation of
the data on the screen, as that is only the  task of the view.

In a traditional MVC design, the controller sends commands to both
the model and the view to update their states. Below is a minimal
example on how to brush a scatterplot under the MVC design implemented
in R \citep{R2013}:

<<mvc-example>>=
brushed = logical(nrow(cars)) # status of the brush indices
model = function(i) {
  brushed[] <<- FALSE
  # set the i-th element of the brush to TRUE
  brushed[i] <<- TRUE
}
view = function(b = brushed) {
  # solid points (19) for b == TRUE, and circles (21) for FALSE
  plot(cars, pch = ifelse(b, 19, 21))
  rect(min(cars[b, 1]), min(cars[b, 2]), max(cars[b, 1]), max(cars[b, 2]), lty=2)
}
controller = function(i) {
  # update the model and then the view
  model(i)
  view()
}
@

When the user brushes the scatterplot, we can obtain the indices of
the points under the brush rectangle (denoted by \texttt{i} in the
code above). Then we pass the indices to the model to change the brush
status (the vector \texttt{brushed}) and redraw the plot. Below we
brush the first four points and then points from the 10th to 28th. Normally
we get the indices of points from the mouse input, and here is only
an emulation.

\begin{figure}
<<mvc-brush, fig.width=3.5, fig.height=3.5, fig.show='hold', out.width='.49\\linewidth', par=TRUE, dev='tikz', cache=TRUE>>=
controller(1:4)  # the first four points
controller(10:28)  # points from 10th to 28th
@

\caption{Brush a scatterplot using the MVC design: brush the first four points (left),
then brush all points from the 10th to 28th. The dashed rectangle denotes the ``brush'',
which is normally created by dragging the cursor over the points.
The \texttt{cars} data
is a built-in dataset in R.\label{fig:mvc-brush}}
\end{figure}


By decoupling the system into three components, we can reuse them
in other places in the implementation. For example, we can call the model or the view separately
without modifying their source code.

The problem with the traditional MVC design is that we have to be
explicit about updating the model and the view in the controller.
In the context of interactive graphics, this can be a burden for developers.
For instance, when there are multiple views in the system, the controller
must notify all views explicitly of all of the changes in the system. When a
new view is added to the system, the  controller
must be updated accordingly.

Ideally we want all views to respond to changes in the model automatically
so there is no additional step of updating the views after the model
is changed. This can be achieved by reactive programming, an object-oriented
programming paradigm based on an event-listener model and targeted at
the propagation of changes in data flows. We
attach listeners on data objects such that (different) events will be triggered
corresponding to changes in data. 
In the above example, the plot will be
updated as soon as object \texttt{brushed} is modified without the need to explicitly calling
\texttt{view()}. This makes it much easier to express the logic of
interactive graphics. In this paper we will discuss how it works as
well its application in interactive graphics.


\section{Related work}


\citet{Whalen05} built an interactive GUI using the MVC pattern to
explore linked data. The GUI was based on the RGtk package (later
evolved into RGtk2 \citep{RGtk2}), and MVC was implemented in the
MVCClass package. \emph{TODO}: need to figure out how she implemented
signals \url{http://www.bioconductor.org/packages/2.11/bioc/html/MVCClass.html}

The iplots package \citep{R-iplots}


\section{Reactive programming}

Our goal is to automatically notify the view whenever there is a change
in the model. For an application of interactive graphics, there are
two types of objects in the model:
\begin{itemize}
\item  data to present in the plots; it is often of a tabular form like
the data frame in R
\item  meta data to store additional information of the plots such as
the axis limits; it is irregular like a list
\end{itemize}
There are two approaches to making them reactive, respectively. We
can use \emph{mutaframes} \citep{R-plumbr} for the data object, and
\emph{reference classes} \citep{Chambers2013} for the meta data.
The fundamental technique underlying them is the \emph{active binding}
in R, thanks to the work of the R core member Luke Tierney.

Active bindings allow events (expressed as functions) to be attached
on objects and these events are executed when objects are assigned
new values. Below is an implementation with active bindings, to continue
the MVC example before:

<<active-binding>>=
reactiveModel = local({
  b = logical(nrow(cars)) # initial status; all FALSE
  function(i) {
    if (!missing(i)) {
      b[] <<- FALSE
      b[i] <<- TRUE # change i-th elements to TRUE
      view(b) # update the view automatically
    }
    b
  }
})
makeActiveBinding('reactiveBrushed', reactiveModel, env = globalenv())
@

We bind a function \texttt{reactiveModel()} to the variable \texttt{reactiveBrushed}
via \texttt{makeActiveBinding()} in base R. When we assign new values
to \texttt{reactiveBrushed}, the function defined in \texttt{reactiveModel()}
will be called: inside the function, the logical variable \texttt{b}
is modified by the indices \texttt{i} and the view is updated accordingly.
The two lines below achieve the same goal as the MVC example in Figure
\ref{fig:mvc-brush}.

<<active-test, eval=FALSE>>=
reactiveBrushed=1:4 # brush the first four points
reactiveBrushed=10:28 # brush points from 10th to 28th
@

Now our only task is to assign indices of the brushed points to \texttt{reactiveBrushed},
since the plot will be updated automatically. A real interactive graphics
system is more complicated that the above toy example, but it shows
the foundation of the pipeline. There are two kinds of interactive
objects in cranvas, as explained in the next two sections.


\subsection{Mutaframes}
Mutaframes are extensions of R data frames, that are being made mutable. This means that changes to its elements can be made anywhere regardless of the current environment. By comparison,
a data frame can only be modified in the environment in which it was
created, unless we use the non-local assignment operator \texttt{<\textcompwordmark{}<-}.
The difference is highlighted in the example below:

<<mf-mutable,package=library(methods)>>=
library(plumbr)
mf = mutaframe(x=1:2*pi) # a mutaframe
df = data.frame(x=1:2*pi) # a normal data frame
c(mf$x[2], df$x[2]) # the 2nd elements in mf and df
f=function() {
mf$x[2]=10
df$x[2]=10
}
f() # modified mf, but not df
c(mf$x[2], df$x[2])
@

As we can see, \texttt{mf} can be modified inside \texttt{f()}, but
\texttt{df} cannot, therefore we can share the same mutaframe across
multiple plots. Another important feature of mutaframes is that we
can attach listeners onto them. A listener is essentially an R function
which is called upon changes in the mutaframe. For interactive graphics,
we can update the views with listeners. Below we create a mutaframe
and attach a listener to it to redraw the scatterplot:

<<mf-listener>>=
mf = mutaframe(cars)
add_listener(mf, function(i, j) {
  plot(mf$speed, mf$dist)
})
@

Now whenever we update \texttt{mf}, the scatterplot will be updated
accordingly. For example, we make a square-root transformation of
the \texttt{dist} variable:

<<sqrt-dist, eval=FALSE>>=
mf$dist = sqrt(mf$dist)
@

A more complex but direct application of mutaframes is the example shown in the movie displayed in figure~\ref{tour}: here, we see a two dimensional grand tour \citep{asimov} through the flea data set (provided in the {\tt tourr} package). After a while, we can see a separation of the data into three clusters (species separate into three distinct multivariate clusters). A two dimensional tour consists of a series of projections into two dimensional space. By choosing projections less than 6 degree apart, a sense of continuity is preserved for the observer. This continuity allows us to identify clusters as groups of points that share a common fate \citep[e.g.][]{wolfe2012sensation}. Internally, the movie-like view is upheld by repeated changes to the $X$ and $Y$ values displayed, which are propagated to the view. Simultaneously, changes are made to a second mutaframe containing information about the axis and labels. 

\begin{figure}
\includemedia[
    width=0.6\linewidth,
    height=0.6\linewidth,
    addresource=movies/flea.mp4,
    activate=onclick,
    deactivate=onclick,
    flashvars={source=movies/flea.mp4}
]{}{VPlayer.swf}
\caption{\label{tour}Grand tour of through the flea data. The data separate into three clusters.}
\end{figure}


\subsection{Reference classes}

R introduced reference classes since version 2.12 thanks to John Chambers.

extension by objectSignals


\section{Application}
Interaction happens on multiple levels. The most common forms of interaction with a display are listed below in decreasing order of immediacy with which this interaction between the user and the display happens:
\begin{description}
\item [\bf Direct manipulation] of graphical objects \citep{cleveland, wills} is at the heart of interactive graphics.  Direct manipulation is what we use only for the highest level of interaction, such as selection or brushing of elements. With a set of different modes (querying, scaling mode as e.g. implemented in xgobi, ggobi \citet{ggobi}) a set of different or additional interactions can be incorporated at the highest level. Another approach is to make use of visual cues \cite{manet, mondrian}, which make areas of interactions visible to the user by changing the cursor upon entering the cue area. Visual cues are usually associated with changes to the resolution of a representation or scales of a display. 
\item [{\bf Input devices}:] most input devices, such as mice or touch pads, allow a finer level of interaction than just click-selection; e.g. all operating platforms and devices specify wheel events (either through the presence of a mouse wheel, a mouse move with additional modifier key, or a touch gesture).  
\item [\bf Keystrokes] can be used for quick access to functions that are also accessible through a (popup) menu or other toolbar. Figure~\ref{map-all} shows an example of a key stroke interaction (arrow keys left and right) to move between a choropleth map of the United States and a population based cartogram. 
\item [\bf Functional access] through the console: Accessor functions allow us to get information about the state of  objects (e.g. get selected elements). Mutator functions enable the user to set a particular state for objects in a display (e.g. set highlighting color to red, set points to size 5).
\end{description}

\begin{figure}
\includegraphics[width=\textwidth]{images/histogram}
\caption{\label{hist}Histogram of sales prices. Sales of \$200k and more are selected and highlighted in yellow. Markers show cue regions. }
\end{figure}
\begin{figure}
\centering
\includegraphics[height=0.55\textwidth]{images/bar}
\includegraphics[height=0.55\textwidth]{images/spine}
\caption{\label{bar} Barchart (left) and spineplot (right) of the number of bedrooms in housing sales. Highlighted are sales of \$200k and higher. Querying gives details on each bin (houses with a particular number of bedrooms) and the selected houses with this bin.}
\end{figure}

On the developer's side, the main idea behind resolving an interaction between the user and the display, is to actually resolve the interaction at the level of the data, but make it appear as if the user had directly interacted with the graphical object. 
%

\begin{figure}
% \includegraphics[width=0.3\textwidth]{images/map-0}
% \includegraphics[width=0.3\textwidth]{images/map-1}
% \includegraphics[width=0.3\textwidth]{images/map-2}
% \includegraphics[width=0.3\textwidth]{images/map-5}
% \includegraphics[width=0.3\textwidth]{images/map-4}
% \includegraphics[width=0.3\textwidth]{images/map-3}
% \includegraphics[width=0.3\textwidth]{images/map-6}
% %\includegraphics[width=0.3\textwidth]{images/map-7}
% \includegraphics[width=0.3\textwidth]{images/map-8}
% %\includegraphics[width=0.3\textwidth]{images/map-9}
% \includegraphics[width=0.3\textwidth]{images/map-10}
\includegraphics[width=\textwidth]{images/map-all.pdf}
\caption{\label{cartogram} Morph from a choropleth chart of the US (top left) to a population based cartogram (bottom right). The color represents electoral votes of states towards the Democratic (blue) or Republican party (red) in the 2012 Presidential election. The arrow indicates  the direction of the morph.  }
\end{figure}

\subsection{Meta data}
Graphical displays are data summaries, and as such they require some level of aggregation of the original data. This information is stored in form of meta data. Meta data is plot specific. Not only are data values stored to render a display, but also the parameters necessary to derive the data values for the display. 
It is those meta data that correspond directly to the graphical elements shown, and with which the user interacts. For resolving the interaction, the aggregation from the original data has to be reversed. Interactions are therefore only feasible in situations that can be reversed. A higher level of aggregation in a display usually requires a more complex data structure for an interaction.

{\tt cranvas} allows the possibility of adding user customized meta information to any display.



\subsection{Linking}
Linking forms the core of communication between multiple views. 
By default, all objects and views are linked that involve variables from the same data set. 
It is feasible to extend this concept to  link different sources or aggregation levels. Linking within the same data set is implicit one-to-one linking. If the same objects are under consideration but are reported in different data sets, we can make this linking explicit. In the example of figure~\ref{linked}, data on states is linked from two different sources, resulting in {\it categorical linking}, as each state in the map is described by multiple locations following the border.
 kNN ($k$ nearest neigbor) linking is based on (multivariate) distance between points. Selecting one point in a view also selects the $k$ closest points in its neighborhood. This can be based on geographical distance as much as more abstract multivariate distances.

\begin{figure}
\includegraphics[height=0.4\textwidth]{images/choropleth}
\includegraphics[height=0.4\textwidth]{images/scatter}
\caption{\label{linked}Linked map (left) and scatterplot (right). Color shading shows (log) state population with darker shades indicating higher values. The scatterplot on the right displays the number of burglaries in 2009 versus the number of motor vehicle thefts by state. There is a strong correlation between the variables, which is mainly induced by a strong underlying correlation with population. Compared to other states, California displays a high number of motor vehicle thefts compared to the number of burglaries.}
\end{figure}
\subsection{Interactions}

The list below shows a set of interactions ordered depending on the level at which it can be resolved: 
\begin{description}
\item[{\bf Zooming and panning}:] are direct interactions with the display, that can be resolved directly without the need of interaction with the original data. In {\tt cranvas}, the core of zooming and panning consists of simple changes to {\tt meta\$limits}.
\item[\bf Querying] is another interaction that usually can be resolved without any further information from the original data. Querying of graphical objects involves, in a first step the display of the corresponding values of the meta data. In the case of the barcharts in figure \ref{bar}, querying of the bins displays information, about the bin's level, the number of records it encompasses, as well as the proportion of the whole data that this bin contains. The same information is also displayed at the level of the selected values in the bar. The proportion shown is the proportion of selected elements within the bin. 

\item[{\bf Brushing, Querying, and Selection}:]  are all (mode-dependent) interactions that require backtracking of one step of aggregation; the histogram of figure~\ref{hist} shows sales prices of all houses sold in Ames, IA from 2008 to 2012. The yellow rectangle corresponds to an an area based selection of all houses with sales of \$200k or more, that triggers a highlighting of all corresponding houses in all displays of the Ames housing data. This includes the histogram itself, where all bins intersecting with the selection rectangle are filled with highlighting color, and all barcharts of the number of bedrooms as shown in figure~\ref{bar}.

Internally, this selection is handled with one step of backtracking:
Once the user draws a selection rectangle, metadata of all graphical objects intersecting with it is investigated. In the case of a histogram, bins are the graphical objects intersecting with a selection rectangle. Corresponding to each bin, meta information is available. This information contains lower and upper limits of an interval on the scale of the variable  and the number of records in the original data with values within those limits. The backtracking corresponds to identifying all records in the original data falling within the limits of the selected bin. The original data contains an internal binary variable {\tt .brushed} encoding selection status of a record. When this status is changed, the change is propagated to all dependencies, which results in an update to all affected views. In the situation of the histogram, a selection corresponds to an update of the {\tt .brushed} variable, which in turn informs all linked views of an update of the highlighting status. One of the dependent views is the histogram itself, which shows highlighting in form of superimposing a histogram of the highlighted records on top of the original histogram. What the user perceives as `selecting' bins is actually a reaction to a change in the internal brushing variable.

\item[{\bf Interactions with graphical objects}]: 
visual cues indicate additional areas of interaction in graphical objects other than the ones representing the data. Figure~\ref{hist} shows several examples of visual cues in a histogram. 
Both anchor point and bin width are graphical representations of plotting parameters for the histogram. The anchor of a histogram is the lower limit of the left most bin. The bin width then defines the interval at which breaks are drawn to define bins. 
Interactions with both anchor and binwidth cues consist of horizontal shifts, which re-set the actual values parametrizing the histogram. Changes to the anchor allow to test for instabilities in the display due to discreteness in the data.  Binwidth changes show the data at different levels of smoothness and therefore allow for a visualization of `big' picture marginal distributions for large bin widths and the investigation of small pattern features, such as multiple modes and gaps in the data for small bin widths. Examples for both of these interactions are available as movies in the supplementary material.
\end{description}





\section{Conclusions}

JS libraries

\section*{Supplementary material}
Movies showing some interactions are available through \hh{What would be a good place for these movies?}
\bibliographystyle{imsart-nameyear}
\bibliography{reactive-programming}


\end{document}
