\documentclass[sts]{imsart}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{url}
\usepackage{media9}
\usepackage[authoryear]{natbib}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true]
 {hyperref}
\hypersetup{
 citecolor=blue,urlcolor=blue}

\newcommand{\hh}[1]{{\color{magenta} #1}}

\begin{document}

<<setup, include=FALSE>>=
library(methods)
library(knitr)
options(replace.assign=TRUE, reindent.spaces=2, width=70)
knit_hooks$set(document=hook_movecode, par = function(before, options, envir) {
  if (before && options$fig.show != "none") {
    par(mar = c(4, 4, 0.1, 0.1), cex.lab = 0.95, cex.axis = 0.9,
        mgp = c(2, 0.7, 0), tcl = -0.3, las = 1)
    if (is.list(options$par)) do.call(par, options$par)
  }
})
set.seed(123)
@

\begin{frontmatter}


\title{Reactive Programming for Interactive Graphics}

\maketitle
\runtitle{Reactive Programming for Interactive Graphics}

\begin{aug}
\author{Yihui Xie\ead[label=e1]{xie@iastate.edu}\ead[label=u1,url]{http://yihui.name}},
\author{Heike Hofmann \ead[label=e2]{hofmann@iastate.edu}\ead[label=u2,url]{http://hofmann.public.iastate.edu}}
\and
\author{Xiaoyue Cheng\ead[label=e3]{xycheng@iastate.edu}\ead[label=u3,url]{http://xycheng.public.iastate.edu}}
\affiliation{Department of Statistics, Iowa State University}

\address{Yihui Xie \printead{e1,u1} and Xiaoyue Cheng \printead{e3,u3} are
Graduate Students, Department of Statistics, Iowa State University; 102
Snedecor Hall, Ames 50011, IA, USA.}

\address{Heike Hofmann is Professor, Department of Statistics, Iowa State
University; 2413 Snedecor Hall, Ames 50011, IA, USA. \printead{e2,u2}}

\runauthor{Y. Xie et al}
\end{aug}

\begin{abstract}
One of the big challenges of developing interactive statistical applications
is the management of the data pipeline, which typically consists of many
modules. The user's interactions needs to be propagated through these
modules and finally be reflected in the output representation. Each
individual module may be easy to develop and manage, but the dependency
structure can be quite challenging. The MVC (Model/View/Controller) pattern
is an attempt to solve the problem by separating the user's interaction from
the representation of the data. In this paper we discuss the paradigm of {\it
reactive programming} in the framework of the MVC architecture and show its
applicability to interactive graphics. Under this paradigm, developers
benefit from the separation of user interaction from the graphical
representation, which makes it easier for users and developers to extend
interactive applications. The implementation is done in the R package \textbf
{cranvas}, which is freely available on Github.
\end{abstract}

\begin{keyword}
\kwd{Reactive programming}
\kwd{Interactive graphics}
\kwd{R language}
\end{keyword}
\end{frontmatter}


\section{Introduction}

%\hh{This needs a gentler introduction -- }
%\hh{
%Start with a discussion of interactive graphics -- where does it come from, }

% ---
% I was assuming the audience should be very familiar with this (Yihui)
% ---

Interactive graphics progresses us beyond the limitations of static
statistical displays, in particular, for exploring high-dimensional data.
With a static image, we can only see one aspect of the data at one time.
Interactive graphics allows us to inspect data dynamically from multiple
angles. For example, we may examine the distribution of a variable from a
histogram, and change its binwidth on the fly without having to manually
redraw the plot again and again according to different values of the binwidth.


The main tasks that an interactive graphics system is supposed to support are:

\begin{enumerate}

  \item Single display interactions, such as modifying the plot attributes
  (brushing, zooming, panning, deletion) and obtaining additional
  information (querying graphical elements);

  \item Linking between different displays of the same dataset or connected
  datasets.

\end{enumerate}

The first set of tasks is easier to solve -- there are a lot of web
applications that allow various single display interactions based on, for
instance, Gapminder \citep{RJ2009}, ManyEyes \citep{viegas2007}, and D3
\citep{bostock2011d3}. That is what people usually associate with
interactive graphics.

Linked graphics is more tricky --- it allows changes across different
displays as well as across different aggregation levels of the data. For
example, suppose we have a scatterplot of the variable $Y$ versus $X$, and a
histogram of $Z$ (all three variables are from the same dataset); when we
highlight a subset of points in the scatterplot, and we need to show the
distribution of the subset of $Z$ in the histogram as well. The key question
is how to let the plots be aware of each other's changes, and respond both
automatically and immediately. There are several types of linking between
plots, such as one-to-one linking, categorical linking, and so on; see \citet
{hurley1988}, \citet{stuetzle1987}, and \citet{mcdonald1990} for some early
demonstrations and implementations. We will show how linking is related to
and achieved by reactive programming later in this paper.

The term ``interactive graphics'' can be ambiguous, as discovered by \citet
{swayne1999}: it may imply the direct manipulation of the graph itself,
manipulation of the graph controls, or even the command-line interaction
with graphs. Nowadays we primarily mean the direct manipulation on graphs,
but other meanings still have their usefulness. For instance, we may change
the binwidth of a histogram through a slider, or brush all the outliers a
scatterplot using command line based a certain numeric criterion, which can
be difficult to do via direct manipulation.

\hh{Cite Graham Wills on reaction time and mention the speed of Qt}

A number of standalone systems for interactive statistical graphics exist.
Early systems include PRIM-9, an interactive computer graphics system to
picture, rotate, isolate and mask data in up to 9 dimensions \citep{prim9}.
Data Desk \citep{velleman1988} and LISP-STAT \citep{tierney1990} provided
tight integration with interactive graphics as well as numerical modeling.
In particular, LISP-STAT is also a programmable environment like R \citep
{R2013}, but unfortunately it has been quite inert nowadays and R seems to
be a much more popular choice. \citet{tierney2005} mentioned a few
approaches towards programmable interactive graphics in LISP-STAT, which
were not implemented due to limitations of toolkits, but will be relatively
straightforward in the framework of R and Qt \citep{Qt}.

More recent packages include XGobi and GGobi \citep{swayne2003,cook07},
MANET \citep{unwin96} and Mondrian \citep{theus02}, which support
interactive displays of multivariate data, but they lack the extensibility,
and tight integration with modeling that R furnishes. The R package iplots
\citep{R-iplots} provides high interaction statistical graphics; it was
written in Java, and communicates with R through the rJava package.

One of the big challenges in the development of interactive statistical
applications is to resolve a user's action on the data level. This is
sometimes referred to as the `plumbing' of interactice graphics. \citet
{buja1988} gave a structure of a viewing pipeline for dynamic scatter plots,
and the some components of the pipeline are no longer a concern today, such
as the so-called ``window-to-viewport'' transformation, because graphics
toolkits like Qt can take care of such low-level details automatically.
\citet{wickham2009plumbing} outlined a more general pipeline for
interactive graphics, but it did not cover implementation details, which is
the focus of our paper and we believe reactive programming will facilitate
the pipeline.

\begin{figure}
\includegraphics[width=\textwidth]{figure/diagram3}

\caption{A part of the pipeline in the \textbf{cranvas} package: it shows
how plots are linked to each other as well as the data source. \label
{fig:pipeline}}

\end{figure}

The R package \textbf{cranvas} \citep{cranvas} is an interactive graphics
system built under the classical Model/View/Controller (MVC) architecture
(Section \ref{sec:mvc}) and adopts the reactive programming paradigm
(Section \ref{sec:reactive}) to achieve interactivity. Figure \ref
{fig:pipeline} shows the basic pipeline in the \textbf{cranvas} package, and
the most important components are mutaframes and meta data objects, which
are ``reactive'' by design and we will explain in detail in Section \ref
{sec:reactive}. The pipeline starts with a data source (a mutaframe) as the
central commander of the system. Any plot can modify the data source as we
interact with the plot, and as soon as the mutaframe is modified, its
reactive nature will propagate the changes to all other plots in the system
automatically. On the other hand, each plot also has its own attributes,
which should not be propagated out of itself, and that is why we have meta
data in the system besides mutaframes. A meta data object is also reactive,
but it is only linked to a specific plot. For instance, we can store the
binwidth of a histogram in its meta data, and when we modify the binwidth,
the histogram will respond automatically.

In following sections, we start with the discussion of the MVC design, which
is also the main path that we follow in the design of \textbf{cranvas}.
Then we add the reactive programming paradigm to the MVC architecture, and
show its applications in an interactive graphics system.

\section{The MVC Architecture}\label{sec:mvc}

The Model/View/Controller triple is a software architecture pattern first
described by \citet{Krasner1988} and invented by Trygve Reenskaug in the
1970's. It is widely used in GUI (Graphical User Interface) applications,
including web applications \citep{leff2001web}. The main reason for its
popularity is because it minimizes the dependencies between different
components of an application.

For example, let us assume that the model component consists of a data
transformation, such as a square-root or log transformation. The model does
not depend on the view, but the view depends on the model in the sense, that
if the data is changed or a different data transformation is chosen, the
view has to be updated to reflect this change. The model developer therefore
never needs to deal with the representation of the data on the screen, as
that is only the task of the view.

In a traditional MVC design, the controller sends commands to both the model
and the view to update their states. Below is a minimal example on how to
brush a scatterplot under the MVC design implemented in R:

<<mvc-example>>=
brushed = logical(nrow(cars)) # status of the brush indices
model = function(i) {
  brushed[] <<- FALSE
  # set the i-th element of the brush to TRUE
  brushed[i] <<- TRUE
}
view = function(b = brushed) {
  # solid points (19) for b == TRUE, and circles (21) for FALSE
  plot(cars, pch = ifelse(b, 19, 21))
  rect(min(cars[b, 1]), min(cars[b, 2]), max(cars[b, 1]), max(cars[b, 2]), lty=2)
}
controller = function(i) {
  # update the model and then the view
  model(i)
  view()
}
@

When the user brushes the scatterplot, we can obtain the indices of the
points under the brush rectangle (denoted by \texttt{i} in the code above).
Then we pass the indices to the model to change the brush status (the vector
\texttt{brushed}) and redraw the plot. Below we brush the first four points
and then points from the 10th to 28th. Normally we get the indices of points
from the mouse input, and here is only an emulation.

\begin{figure}
<<mvc-brush, fig.width=3.5, fig.height=3.5, fig.show='hold', out.width='.49\\linewidth', par=TRUE, dev='tikz', cache=TRUE>>=
controller(1:4)  # the first four points
controller(10:28)  # points from 10th to 28th
@

\caption{Brush a scatterplot using the MVC design: brush the first four
points (left), then brush all points from the 10th to 28th. The dashed
rectangle denotes the ``brush'', which is normally created by dragging the
cursor over the points. The \texttt{cars} data is a built-in dataset in R.
\label{fig:mvc-brush}}

\end{figure}


By decoupling the system into three components, we can reuse them in other
places in the implementation. For example, we can call the model or the view
separately without modifying their source code.

The problem with the traditional MVC design is that we have to be explicit
about updating the model and the view in the controller. In the context of
interactive graphics, this can be a burden for developers. For instance,
when there are multiple views in the system, the controller must notify all
views explicitly of all of the changes in the system. When a new view is
added to the system, the  controller must be updated accordingly.

Ideally we want all views to respond to changes in the model automatically
so there is no additional step of updating the views after the model is
changed. This can be achieved by reactive programming, an object-oriented
programming paradigm based on an event-listener model and targeted at the
propagation of changes in data flows. We attach listeners on data objects
such that (different) events will be triggered corresponding to changes in
data. In the above example, the plot will be updated as soon as the object
\texttt{brushed} is modified without the need to explicitly calling \texttt
{view()}. This makes it much easier to express the logic of interactive
graphics. In this paper we will discuss how it works as well as its
application in interactive graphics. Shiny \citep{shiny} is another
application of reactive programming in the R community, which makes it easy
to interact between HTML elements and R, but it does not have a specific
emphasis on statistical graphics.

There have been a number of R packages attempting to solve similar problems
as we tried to solve in \textbf{cranvas}. For example, \citet{Whalen05}
built an interactive GUI system using the MVC pattern to explore linked
data. The GUI was based on the RGtk package (later evolved into RGtk2 \citep
{RGtk2}), and MVC was implemented in the MVCClass package.

\section{Reactive programming}\label{sec:reactive}

Our goal is to automatically notify the view whenever there is a change in
the model. For an application of interactive graphics in the \textbf
{cranvas} package, there are two types of objects in the model:

\begin{itemize}

\item  data to be presented in the plots; it is often of a tabular form like
data frames in R

\item  meta data to store additional information of the plots such as
the axis limits; it is irregular like a list in R

\end{itemize}

There are two approaches to making them reactive, respectively. We can use
\emph{mutaframes} \citep{R-plumbr} for the data object, and \emph{reference
classes} \citep{Chambers2013} for the meta data. The fundamental technique
underlying them is the \emph{active binding} in R, thanks to the work of the
R core team (in particular, Luke Tierney). For details, see the
documentation of \texttt{makeActiveBinding} in R. Both mutaframes and
reference classes use active bindings to make elements inside them (such as
data columns, or list members) reactive whenever they are modified.

Active bindings allow events (expressed as functions) to be attached
on objects and these events are executed when objects are assigned
new values. Below is an implementation with active bindings, to continue
the MVC example before:

<<active-binding>>=
reactiveModel = local({
  b = logical(nrow(cars)) # initial status; all FALSE
  function(i) {
    if (!missing(i)) {
      b[] <<- FALSE
      b[i] <<- TRUE # change i-th elements to TRUE
      view(b) # update the view automatically
    }
    b
  }
})
makeActiveBinding('reactiveBrush', reactiveModel, env = globalenv())
@

We bind a function \texttt{reactiveModel()} to the variable \texttt{reactiveBrush}
through \texttt{makeActiveBinding()} in base R. When we assign new values
to \texttt{reactiveBrush}, the function defined in \texttt{reactiveModel()}
will be called: inside the function, the logical variable \texttt{b}
is modified by the indices \texttt{i} and the view is updated accordingly.
The two lines below achieve the same goal as the MVC example in Figure
\ref{fig:mvc-brush}.

<<active-test, eval=FALSE>>=
reactiveBrush=1:4 # brush the first four points
reactiveBrush=10:28 # brush points from 10th to 28th
@

Now our only task is to assign indices of the brushed points to \texttt
{reactiveBrush}, since the plot will be updated automatically. A real
interactive graphics system is more complicated that the above toy example,
but it shows the foundation of the pipeline. The two kinds of interactive
objects in \textbf{cranvas} are explained in the next two sections,
respectively.


\subsection{Mutaframes}

Mutaframes are extensions to R data frames, that are being made mutable.
This means that changes to its elements can be made anywhere regardless of
the current environment. By comparison, a data frame can only be modified in
the environment in which it was created, unless we use the non-local
assignment operator \texttt{<\textcompwordmark{}<-}. The difference is
highlighted in the example below:

<<mf-mutable>>=
library(plumbr)
mf = mutaframe(x=1:2*pi) # a mutaframe
df = data.frame(x=1:2*pi) # a normal data frame
c(mf$x[2], df$x[2]) # the 2nd elements in mf and df
f=function() {
mf$x[2]=10
df$x[2]=10
}
f() # modified mf, but not df
c(mf$x[2], df$x[2])
@

As we can see, \texttt{mf} can be modified inside \texttt{f()}, but
\texttt{df} cannot, therefore we can share the same mutaframe across
multiple plots. Another important feature of mutaframes is that we
can attach listeners onto them. A listener is essentially an R function
which is called upon changes in the mutaframe. For interactive graphics,
we can update the views with listeners. Below we create a mutaframe
and attach a listener to it to redraw the scatterplot:

<<mf-listener>>=
mf = mutaframe(cars)
add_listener(mf, function(i, j) {
  plot(mf$speed, mf$dist)
})
@

Now whenever we update \texttt{mf}, the scatterplot will be updated
accordingly. For example, we make a square-root transformation of
the \texttt{dist} variable:

<<sqrt-dist, eval=FALSE>>=
mf$dist = sqrt(mf$dist)
@

A more complex but direct application of mutaframes is the example shown in
the movie displayed in Figure \ref{tour}: here, we see a two dimensional
grand tour \citep{asimov1985} through the flea data set (provided in the {\tt
tourr} package). After a while, we can see a separation of the data into
three clusters (species separate into three distinct multivariate clusters).
A two dimensional tour consists of a series of projections into two
dimensional space. By choosing projections less than 6 degree apart, a sense
of continuity is preserved for the observer. This continuity allows us to
identify clusters as groups of points that share a common fate \citep[e.g.]
[]{wolfe2012sensation}. Internally, the movie-like view is upheld by
repeated changes to the $X$ and $Y$ values displayed, which are propagated
to the view.

\begin{figure}
\includegraphics[width=0.6\linewidth, height=0.6\linewidth]{figure/tour}

\caption{A grand tour through the flea data. The points are separated into
three clusters. Watch the video online at \url
{http://cranvas.org/examples/qtour.html}. \label{tour}}

\end{figure}

Interactivity of a mutaframe can be propagated to its subsets, and this
allows us to build multiple applications based on one mutaframe and its
offsprings \citep{hurley1988}. For instance, we can select a subset of
points in a scatterplot, obtain their indices, and use the indices to subset
the original mutaframe to draw a new plot. Then the new plot is naturally
connected with the original plot: when we interact with the new plot, the
interaction will be passed to the original plot, and vice versa.

\subsection{Reference classes}

R introduced reference classes since version 2.12 (thanks to John Chambers).
This made it possible to create objects with fields that can be accessed by
reference. A consequence of this feature is that such objects can be used
for storing meta data in the graphics system, and the data can be easily
modified outside of plotting functions. For instance, we store the axes
limits in an object \texttt{meta} as \texttt{meta\$limits} (in other words,
\texttt{limits} is a field of \texttt{meta}). After the plot has been drawn,
we can still modify its limits via command line and the new limits will be
available to the internal members of the plotting function. This is
inconvenient, if not impossible, under the usual copy-on-modify semantics in
R.

What is more important in our system is the extension by the \textbf
{objectSignals} package \citep{objectSignals} based on reference classes.
The objects created from this package are called ``signal objects'', which
are basically special reference classes objects with listeners attached on
them. This is similar to mutaframes described before, but we can create
objects of arbitrary structures. The difference between mutaframes and
signal objects is similar to the difference between data frames and lists in
R.

\begin{figure}
\includegraphics[width=.7\textwidth]{figure/diagram1}
\includegraphics[width=.9\textwidth]{figure/diagram2}
\end{figure}

\section{An Anatomy of Interactions}

In this section, we show how some common interactions, including brushing,
zooming, and querying, etc, were implemented in the \textbf{cranvas}
package. The data infrastructure is based on mutaframes and reference
classes, as introduced in the previous section. The actual drawing is based
on the packages \textbf{qtbase} \citep{qtbase} and \textbf{qtpaint} \citep
{qtpaint}, which connect R to Qt \citep{verzani2012}.

Interaction happens on multiple levels. The most common forms of interaction
with a display are listed below in decreasing order of immediacy with which
this interaction between the user and the display happens:

\begin{description}

\item [\bf Direct manipulation] of graphical objects \citep{becker1987, wills1999}
is at the heart of interactive graphics.  Direct manipulation is what we use only
for the highest level of interaction, such as selection or brushing of elements.
With a set of different modes (querying, scaling mode as e.g. implemented in XGobi,
GGobi \citep{swayne2003}) a set of different or additional interactions can be
incorporated at the highest level. Another approach is to make use of visual cues
\citep{unwin96, theus02}, which make areas of interactions visible to the user by
changing the cursor upon entering the cue area. Visual cues are usually associated
with changes to the resolution of a representation or scales of a display.

\item [{\bf Input devices}:] most input devices, such as mice or touch pads,
allow a finer level of interaction than just click-selection; e.g. all operating
platforms and devices specify wheel events (either through the presence of a
mouse wheel, a mouse move with additional modifier key, or a touch gesture).

\item [\bf Keystrokes] can be used for quick access to functions that are also
accessible through a (popup) menu or other toolbar. Figure \ref{cartogram} shows
an example of a key stroke interaction (arrow keys left and right) to move
between a choropleth map of the United States and a population based cartogram.

\item [\bf Functional access] through the console: Accessor functions allow us
to get information about the state of  objects (e.g. get selected elements).
Mutator functions enable the user to set a particular state for objects in a
display (e.g. set highlighting color to red, set points to size 5).
\end{description}

\begin{figure}
\includegraphics[width=\textwidth]{images/histogram}
\caption{\label{hist}Histogram of sales prices. Sales of \$200k and more are selected and highlighted in yellow. Markers show cue regions. }
\end{figure}
\begin{figure}
\centering
\includegraphics[height=0.55\textwidth]{images/bar}
\includegraphics[height=0.55\textwidth]{images/spine}
\caption{\label{bar} Barchart (left) and spineplot (right) of the number of bedrooms in housing sales. Highlighted are sales of \$200k and higher. Querying gives details on each bin (houses with a particular number of bedrooms) and the selected houses with this bin.}
\end{figure}

On the developer's side, the main idea behind resolving an interaction
between the user and the display, is to actually resolve the interaction at
the level of the data, but make it appear as if the user had directly
interacted with the graphical object.

\begin{figure}
% \includegraphics[width=0.3\textwidth]{images/map-0}
% \includegraphics[width=0.3\textwidth]{images/map-1}
% \includegraphics[width=0.3\textwidth]{images/map-2}
% \includegraphics[width=0.3\textwidth]{images/map-5}
% \includegraphics[width=0.3\textwidth]{images/map-4}
% \includegraphics[width=0.3\textwidth]{images/map-3}
% \includegraphics[width=0.3\textwidth]{images/map-6}
% %\includegraphics[width=0.3\textwidth]{images/map-7}
% \includegraphics[width=0.3\textwidth]{images/map-8}
% %\includegraphics[width=0.3\textwidth]{images/map-9}
% \includegraphics[width=0.3\textwidth]{images/map-10}
\includegraphics[width=\textwidth]{images/map-all.pdf}
\caption{\label{cartogram} Morph from a choropleth chart of the US (top left) to a population based cartogram (bottom right). The color represents electoral votes of states towards the Democratic (blue) or Republican party (red) in the 2012 Presidential election. The arrow indicates  the direction of the morph.  }
\end{figure}

\subsection{Meta data}

% supporting info
Graphical displays are data summaries, and as such they require some level
of aggregation of the original data. This information is stored in form of
meta data. Meta data is plot specific. Not only are data values stored to
render a display, but also the parameters necessary to derive the data
values for the display. It is those meta data that correspond directly to
the graphical elements shown, and with which the user interacts. For
resolving the interaction, the aggregation from the original data has to be
reversed. Interactions are therefore only feasible in situations that can be
reversed. A higher level of aggregation in a display usually requires a more
complex data structure for an interaction.

Since the data structure of meta data is very flexible, its application can be very wide.
The {\tt cranvas} package allows the possibility of adding user customized meta
information to any display. For example, the user can specify a function in the
meta data to generate text labels when querying a plot.



\subsection{Linking}

Linking forms the core of communication between multiple views. By default,
all objects and views are linked that involve variables from the same data
set. It is feasible to extend this concept to  link different sources or
aggregation levels. Linking within the same data set is implicit one-to-one
linking. If the same objects are under consideration but are reported in
different data sets, we can make this linking explicit. In the example of
Figure \ref{linked}, data on states is linked from two different sources,
resulting in {\it categorical linking}, as each state in the map is
described by multiple locations following the border. kNN ($k$ nearest
neighbor) linking is based on (multivariate) distance between points.
Selecting one point in a view also selects the $k$ closest points in its
neighborhood. This can be based on geographical distance as much as more
abstract multivariate distances.

\begin{figure}
\includegraphics[height=0.4\textwidth]{images/choropleth}
\includegraphics[height=0.4\textwidth]{images/scatter}
\caption{\label{linked}Linked map (left) and scatterplot (right). Color shading shows (log) state population with darker shades indicating higher values. The scatterplot on the right displays the number of burglaries in 2009 versus the number of motor vehicle thefts by state. There is a strong correlation between the variables, which is mainly induced by a strong underlying correlation with population. Compared to other states, California displays a high number of motor vehicle thefts compared to the number of burglaries.}
\end{figure}
\subsection{Interactions}

The list below shows a set of interactions ordered depending on the level at
which it can be resolved:

\begin{description}

\item[{\bf Zooming and panning}] are direct interactions with the display,
that can be resolved directly without the need of interaction with the
original data. In {\tt cranvas}, the core of zooming and panning consists of
simple changes to {\tt meta\$limits}.

\item[\bf Querying] is another interaction that usually can be resolved
without any further information from the original data. Querying of
graphical objects involves, in a first step the display of the corresponding
values of the meta data. In the case of the barcharts in Figure \ref{bar},
querying of the bins displays information, about the bin's level, the number
of records it encompasses, as well as the proportion of the whole data that
this bin contains. The same information is also displayed at the level of
the selected values in the bar. The proportion shown is the proportion of
selected elements within the bin.

\item[{\bf Brushing, Querying, and Selection}] are all (mode-dependent)
interactions that require backtracking of one step of aggregation; the
histogram of Figure \ref{hist} shows sales prices of all houses sold in
Ames, IA from 2008 to 2012. The yellow rectangle corresponds to an an area
based selection of all houses with sales of \$200k or more, that triggers a
highlighting of all corresponding houses in all displays of the Ames housing
data. This includes the histogram itself, where all bins intersecting with
the selection rectangle are filled with highlighting color, and all
barcharts of the number of bedrooms as shown in Figure \ref{bar}.

Internally, this selection is handled with one step of backtracking: Once
the user draws a selection rectangle, meta data of all graphical objects
intersecting with it is investigated. In the case of a histogram, bins are
the graphical objects intersecting with a selection rectangle. Corresponding
to each bin, meta information is available. This information contains lower
and upper limits of an interval on the scale of the variable  and the number
of records in the original data with values within those limits. The
backtracking corresponds to identifying all records in the original data
falling within the limits of the selected bin. The original data contains an
internal binary variable {\tt .brushed} encoding selection status of a
record. When this status is changed, the change is propagated to all
dependencies, which results in an update to all affected views. In the
situation of the histogram, a selection corresponds to an update of the {\tt
.brushed} variable, which in turn informs all linked views of an update of
the highlighting status. One of the dependent views is the histogram itself,
which shows highlighting in form of superimposing a histogram of the
highlighted records on top of the original histogram. What the user
perceives as `selecting' bins is actually a reaction to a change in the
internal brushing variable.

\item[{\bf Interactions with graphical objects}]: visual cues indicate
additional areas of interaction in graphical objects other than the ones
representing the data. Figure \ref{hist} shows several examples of visual
cues in a histogram. Both anchor point and bin width are graphical
representations of plotting parameters for the histogram. The anchor of a
histogram is the lower limit of the left most bin. The bin width then
defines the interval at which breaks are drawn to define bins. Interactions
with both anchor and binwidth cues consist of horizontal shifts, which
re-set the actual values parametrizing the histogram. Changes to the anchor
allow to test for instabilities in the display due to discreteness in the
data.  Binwidth changes show the data at different levels of smoothness and
therefore allow for a visualization of `big' picture marginal distributions
for large bin widths and the investigation of small pattern features, such
as multiple modes and gaps in the data for small bin widths. Examples for
both of these interactions are available as movies in the supplementary
material.

\end{description}



\section{Discussion and Conclusions}

The \textbf{cranvas} package has a clear distinction with these packages in terms of
the underlying data structure. The plotting pipeline is expressed and attached to
the data as well as the meta data. Using the reactive programming model, the user
does not need to pay attention to the whole pipeline, which makes it easy to extend
this system. For example, implementing the tour is nothing but to draw a scatterplot
(of projected variables), and keep on modifying the data, because the data will
update the scene automatically upon changes.

The future work of \textbf{cranvas} is to include more plot types such as hexbin plots
and scatterplot matrices, and allow users to define how the system reacts to changes.

% what reactive programming enables cranvas to do and other systems cannot
% easily do is interaction from command line besides direct manipulation

\section*{Supplementary material}
The \textbf{cranvas} package is available on GitHub at \url{https://github.com/ggobi/cranvas}.
We have movies showing some interactions that are available through the website
\url{http://cranvas.org}.

\bibliographystyle{imsart-nameyear}
\bibliography{reactive-programming}


\end{document}
